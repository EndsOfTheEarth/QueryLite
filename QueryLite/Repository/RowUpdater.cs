/*
 * MIT License
 *
 * Copyright (c) 2026 EndsOfTheEarth
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 **/
using QueryLite.Databases;
using QueryLite.Databases.PostgreSql.Collectors;
using QueryLite.Databases.Sqlite.Collectors;
using QueryLite.Databases.SqlServer;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Text;

namespace QueryLite {

    public interface IRowUpdaterCollection { }

    public class RowUpdaterCollection<TABLE, ROW> : IRowUpdaterCollection where TABLE : ATable where ROW : IEquatable<ROW> {

        //SQL Server and PostgreSql are the only two supported databases for now so it is quicker to have two fields than
        //manage a collection and implement locking etc.
        private RowUpdater<TABLE, ROW>? _sqlServerUpdater;
        private RowUpdater<TABLE, ROW>? _postgreSqlUpdater;
        private RowUpdater<TABLE, ROW>? _sqliteSqlUpdater;

        public RowUpdater<TABLE, ROW>? GetUpdater(DatabaseType databaseType) {

            if(databaseType == DatabaseType.SqlServer) {
                return _sqlServerUpdater;
            }
            else if(databaseType == DatabaseType.PostgreSql) {
                return _postgreSqlUpdater;
            }
            else if(databaseType == DatabaseType.Sqlite) {
                return _sqliteSqlUpdater;
            }            
            throw new Exception($"Unsupported database type '{databaseType}'");
        }

        public void SetUpdater(DatabaseType databaseType, RowUpdater<TABLE, ROW> rowUpdaters) {

            if(databaseType == DatabaseType.SqlServer) {
                _sqlServerUpdater = rowUpdaters;
            }
            else if(databaseType == DatabaseType.PostgreSql) {
                _postgreSqlUpdater = rowUpdaters;
            }
            else if(databaseType == DatabaseType.Sqlite) {
                _sqliteSqlUpdater = rowUpdaters;
            }
            else {
                throw new Exception($"Unsupported database type '{databaseType}'");
            }
        }
    }

    public class RowUpdater<TABLE, ROW> where TABLE : ATable where ROW : IEquatable<ROW> {

        private ColumnAndSetter<ROW>[] AutoGeneratedColumns { get; }

        public string InsertSql { get; }
        public string UpdateSql { get; }
        public string DeleteSql { get; }

        private List<Func<ROW, DbParameter>> InsertParameterCreators { get; }
        private List<Func<ROW, DbParameter>> UpdateParameterCreators { get; }
        private List<Func<ROW, DbParameter>> WhereClauseParameterCreators { get; }


        public RowUpdater(TABLE table, List<ColumnAndSetter<ROW>> insertColumnAndSetters,
                           List<ColumnAndSetter<ROW>> updateColumnAndSetters,
                           List<ColumnAndSetter<ROW>> whereColumns,
                           IDatabase database) {

            AutoGeneratedColumns = whereColumns.Where(cs => cs.Column.IsAutoGenerated).ToArray();

            int count = 0;

            foreach(ColumnAndSetter<ROW> cs in insertColumnAndSetters) {
                cs.ParameterName = ParamNameCache.GetName(count++);
            }
            foreach(ColumnAndSetter<ROW> cs in updateColumnAndSetters) {
                cs.ParameterName = ParamNameCache.GetName(count++);
            }
            foreach(ColumnAndSetter<ROW> cs in whereColumns) {
                cs.ParameterName = ParamNameCache.GetName(count++);
            }

            InsertSql = CreateInsertSql(database, table, insertColumnAndSetters, returningColumns: AutoGeneratedColumns);
            InsertParameterCreators = GenerateParameterCreators(insertColumnAndSetters, database.ParameterMapper);

            UpdateSql = CreateUpdateSql(database, table, updateColumnAndSetters, whereColumns);
            UpdateParameterCreators = GenerateParameterCreators(updateColumnAndSetters, database.ParameterMapper);
            WhereClauseParameterCreators = GenerateParameterCreators(whereColumns, database.ParameterMapper);

            DeleteSql = CreateDeleteSql(database, table, whereColumns);
        }

        /// <summary>
        /// Creates a list of create parameter functions for the provided list of columns.
        /// </summary>
        private static List<Func<ROW, DbParameter>> GenerateParameterCreators(List<ColumnAndSetter<ROW>> columnAndSetters, IPreparedParameterMapper parameterMapper) {

            List<Func<ROW, DbParameter>> list = new List<Func<ROW, DbParameter>>(columnAndSetters.Count);

            foreach(ColumnAndSetter<ROW> cs in columnAndSetters) {
                CreateParameterDelegate createParameter = parameterMapper!.GetCreateParameterDelegate(cs.Column.Type);
                list.Add(row => createParameter(cs.ParameterName!, cs.Getter(row)));
            }
            return list;
        }

        private static void SetParameters(ROW row, DbParameterCollection parameters, List<Func<ROW, DbParameter>> parameterCreators) {

            foreach(Func<ROW, DbParameter> creator in parameterCreators) {
                parameters.Add(creator(row));
            }
        }

        public int Insert(ROW newRow, Transaction transaction, QueryTimeout? timeout, string debugName) {

            ArgumentNullException.ThrowIfNull(transaction);
            ArgumentNullException.ThrowIfNull(debugName);

            if(timeout is null) {
                timeout = TimeoutLevel.ShortInsert;
            }
            bool hasEvents = Settings.HasEvents;

            long? startTicks = hasEvents ? Stopwatch.GetTimestamp() : null;

            DateTimeOffset? start = hasEvents ? DateTimeOffset.Now : null;

            int rowsEffected = 0;

            try {

                if(hasEvents) {

                    Settings.FireQueryExecutingEvent(
                        database: transaction.Database,
                        sql: InsertSql,
                        queryType: QueryType.Insert,
                        start: start,
                        isolationLevel: transaction.IsolationLevel,
                        transactionId: transaction.TransactionId,
                        timeout: timeout.Value,
                        debugName: debugName
                    );
                }

#if DEBUG
                DebugHelper.HitBreakPoint(QueryType.Insert);
#endif

                using(DbCommand command = transaction.CreateCommand(timeout.Value)) {

                    command.CommandText = InsertSql;

                    SetParameters(newRow, command.Parameters, InsertParameterCreators);

                    if(AutoGeneratedColumns.Length > 0) {

                        using(DbDataReader reader = command.ExecuteReader()) {

                            reader.Read();

                            IResultRow resultRow;

                            if(transaction.Database.DatabaseType == DatabaseType.SqlServer) {
                                resultRow = new SqlServerResultRowCollector(reader);
                            }
                            else if(transaction.Database.DatabaseType == DatabaseType.PostgreSql) {
                                resultRow = new PostgreSqlResultRowCollector(reader);
                            }
                            else if(transaction.Database.DatabaseType == DatabaseType.Sqlite) {
                                resultRow = new SqliteResultRowCollector(reader);
                            }
                            else {
                                throw new Exception($"Unknown database type == {transaction.Database.DatabaseType}");
                            }

                            foreach(ColumnAndSetter<ROW> cs in AutoGeneratedColumns) {
                                cs.Setter(newRow, resultRow);
                                rowsEffected++;
                            }
                        }
                    }
                    else {
                        rowsEffected = command.ExecuteNonQuery();
                    }

                    if(hasEvents) {

                        Settings.FireQueryPerformedEvent(
                            database: transaction.Database,
                            sql: InsertSql,
                            rows: 0,
                            rowsEffected: rowsEffected,
                            queryType: QueryType.Insert,
                            result: null,
                            start: start,
                            end: DateTimeOffset.Now,
                            elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                            exception: null,
                            isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                            transactionId: transaction?.TransactionId,
                            timeout: timeout.Value,
                            isAsync: true,
                            debugName: debugName
                        );
                    }
                }
            }
            catch(Exception ex) {

                if(hasEvents) {

                    Settings.FireQueryPerformedEvent(
                        database: transaction.Database,
                        sql: InsertSql,
                        rows: 0,
                        rowsEffected: 0,
                        queryType: QueryType.Insert,
                        result: null,
                        start: start,
                        end: DateTimeOffset.Now,
                        elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                        exception: ex,
                        isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                        transactionId: transaction?.TransactionId,
                        timeout: timeout.Value,
                        isAsync: true,
                        debugName: debugName
                    );
                }
                throw;
            }
            return rowsEffected;
        }

        public async Task<int> InsertAsync(ROW newRow, Transaction transaction, QueryTimeout? timeout, string debugName, CancellationToken ct) {

            ArgumentNullException.ThrowIfNull(transaction);
            ArgumentNullException.ThrowIfNull(debugName);

            if(timeout is null) {
                timeout = TimeoutLevel.ShortInsert;
            }
            bool hasEvents = Settings.HasEvents;

            long? startTicks = hasEvents ? Stopwatch.GetTimestamp() : null;

            DateTimeOffset? start = hasEvents ? DateTimeOffset.Now : null;

            int rowsEffected = 0;

            try {

                if(hasEvents) {

                    Settings.FireQueryExecutingEvent(
                        database: transaction.Database,
                        sql: InsertSql,
                        queryType: QueryType.Insert,
                        start: start,
                        isolationLevel: transaction.IsolationLevel,
                        transactionId: transaction.TransactionId,
                        timeout: timeout.Value,
                        debugName: debugName
                    );
                }

#if DEBUG
                DebugHelper.HitBreakPoint(QueryType.Insert);
#endif

                await using(DbCommand command = await transaction.CreateCommandAsync(timeout.Value, ct)) {

                    command.CommandText = InsertSql;

                    SetParameters(newRow, command.Parameters, InsertParameterCreators);

                    if(AutoGeneratedColumns.Length > 0) {

                        await using(DbDataReader reader = await command.ExecuteReaderAsync(ct)) {

                            await reader.ReadAsync(ct);

                            IResultRow resultRow;

                            if(transaction.Database.DatabaseType == DatabaseType.SqlServer) {
                                resultRow = new SqlServerResultRowCollector(reader);
                            }
                            else if(transaction.Database.DatabaseType == DatabaseType.PostgreSql) {
                                resultRow = new PostgreSqlResultRowCollector(reader);
                            }
                            else if(transaction.Database.DatabaseType == DatabaseType.Sqlite) {
                                resultRow = new SqliteResultRowCollector(reader);
                            }
                            else {
                                throw new Exception($"Unknown database type == {transaction.Database.DatabaseType}");
                            }

                            foreach(ColumnAndSetter<ROW> cs in AutoGeneratedColumns) {
                                cs.Setter(newRow, resultRow);
                                rowsEffected++;
                            }
                        }
                    }
                    else {
                        rowsEffected = await command.ExecuteNonQueryAsync(ct);
                    }

                    if(hasEvents) {

                        Settings.FireQueryPerformedEvent(
                            database: transaction.Database,
                            sql: InsertSql,
                            rows: 0,
                            rowsEffected: rowsEffected,
                            queryType: QueryType.Insert,
                            result: null,
                            start: start,
                            end: DateTimeOffset.Now,
                            elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                            exception: null,
                            isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                            transactionId: transaction?.TransactionId,
                            timeout: timeout.Value,
                            isAsync: true,
                            debugName: debugName
                        );
                    }
                }
            }
            catch(Exception ex) {

                if(hasEvents) {

                    Settings.FireQueryPerformedEvent(
                        database: transaction.Database,
                        sql: InsertSql,
                        rows: 0,
                        rowsEffected: 0,
                        queryType: QueryType.Insert,
                        result: null,
                        start: start,
                        end: DateTimeOffset.Now,
                        elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                        exception: ex,
                        isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                        transactionId: transaction?.TransactionId,
                        timeout: timeout.Value,
                        isAsync: true,
                        debugName: debugName
                    );
                }
                throw;
            }
            return rowsEffected;
        }

        public int Update(ROW oldRow, ROW newRow, Transaction transaction, QueryTimeout? timeout, string debugName) {

            ArgumentNullException.ThrowIfNull(transaction);
            ArgumentNullException.ThrowIfNull(debugName);

            if(timeout is null) {
                timeout = TimeoutLevel.ShortUpdate;
            }
            bool hasEvents = Settings.HasEvents;

            long? startTicks = hasEvents ? Stopwatch.GetTimestamp() : null;

            DateTimeOffset? start = hasEvents ? DateTimeOffset.Now : null;

            int rowsEffected;

            try {

                if(hasEvents) {

                    Settings.FireQueryExecutingEvent(
                        database: transaction.Database,
                        sql: UpdateSql,
                        queryType: QueryType.Update,
                        start: start,
                        isolationLevel: transaction.IsolationLevel,
                        transactionId: transaction.TransactionId,
                        timeout: timeout.Value,
                        debugName: debugName
                    );
                }

#if DEBUG
                DebugHelper.HitBreakPoint(QueryType.Update);
#endif

                using(DbCommand command = transaction.CreateCommand(timeout.Value)) {

                    command.CommandText = UpdateSql;

                    SetParameters(newRow, command.Parameters, UpdateParameterCreators);

                    SetParameters(oldRow, command.Parameters, WhereClauseParameterCreators);

                    rowsEffected = command.ExecuteNonQuery();

                    if(hasEvents) {

                        Settings.FireQueryPerformedEvent(
                            database: transaction.Database,
                            sql: UpdateSql,
                            rows: 0,
                            rowsEffected: rowsEffected,
                            queryType: QueryType.Update,
                            result: null,
                            start: start,
                            end: DateTimeOffset.Now,
                            elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                            exception: null,
                            isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                            transactionId: transaction?.TransactionId,
                            timeout: timeout.Value,
                            isAsync: true,
                            debugName: debugName
                        );
                    }
                }
            }
            catch(Exception ex) {

                if(hasEvents) {

                    Settings.FireQueryPerformedEvent(
                        database: transaction.Database,
                        sql: UpdateSql,
                        rows: 0,
                        rowsEffected: 0,
                        queryType: QueryType.Update,
                        result: null,
                        start: start,
                        end: DateTimeOffset.Now,
                        elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                        exception: ex,
                        isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                        transactionId: transaction?.TransactionId,
                        timeout: timeout.Value,
                        isAsync: true,
                        debugName: debugName
                    );
                }
                throw;
            }
            return rowsEffected;
        }

        public async Task<int> UpdateAsync(ROW oldRow, ROW newRow, Transaction transaction, QueryTimeout? timeout, string debugName, CancellationToken ct) {

            ArgumentNullException.ThrowIfNull(transaction);
            ArgumentNullException.ThrowIfNull(debugName);

            if(timeout is null) {
                timeout = TimeoutLevel.ShortUpdate;
            }
            bool hasEvents = Settings.HasEvents;

            long? startTicks = hasEvents ? Stopwatch.GetTimestamp() : null;

            DateTimeOffset? start = hasEvents ? DateTimeOffset.Now : null;

            int rowsEffected;

            try {

                if(hasEvents) {

                    Settings.FireQueryExecutingEvent(
                        database: transaction.Database,
                        sql: UpdateSql,
                        queryType: QueryType.Update,
                        start: start,
                        isolationLevel: transaction.IsolationLevel,
                        transactionId: transaction.TransactionId,
                        timeout: timeout.Value,
                        debugName: debugName
                    );
                }

#if DEBUG
                DebugHelper.HitBreakPoint(QueryType.Update);
#endif

                await using(DbCommand command = await transaction.CreateCommandAsync(timeout.Value, ct)) {

                    command.CommandText = UpdateSql;

                    SetParameters(newRow, command.Parameters, UpdateParameterCreators);

                    SetParameters(oldRow, command.Parameters, WhereClauseParameterCreators);

                    rowsEffected = await command.ExecuteNonQueryAsync(ct);

                    if(hasEvents) {

                        Settings.FireQueryPerformedEvent(
                            database: transaction.Database,
                            sql: UpdateSql,
                            rows: 0,
                            rowsEffected: rowsEffected,
                            queryType: QueryType.Update,
                            result: null,
                            start: start,
                            end: DateTimeOffset.Now,
                            elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                            exception: null,
                            isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                            transactionId: transaction?.TransactionId,
                            timeout: timeout.Value,
                            isAsync: true,
                            debugName: debugName
                        );
                    }
                }
            }
            catch(Exception ex) {

                if(hasEvents) {

                    Settings.FireQueryPerformedEvent(
                        database: transaction.Database,
                        sql: UpdateSql,
                        rows: 0,
                        rowsEffected: 0,
                        queryType: QueryType.Update,
                        result: null,
                        start: start,
                        end: DateTimeOffset.Now,
                        elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                        exception: ex,
                        isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                        transactionId: transaction?.TransactionId,
                        timeout: timeout.Value,
                        isAsync: true,
                        debugName: debugName
                    );
                }
                throw;
            }
            return rowsEffected;
        }

        public int Delete(ROW existingRow, Transaction transaction, QueryTimeout? timeout, string debugName) {

            ArgumentNullException.ThrowIfNull(transaction);
            ArgumentNullException.ThrowIfNull(debugName);

            if(timeout is null) {
                timeout = TimeoutLevel.ShortDelete;
            }
            bool hasEvents = Settings.HasEvents;

            long? startTicks = hasEvents ? Stopwatch.GetTimestamp() : null;

            DateTimeOffset? start = hasEvents ? DateTimeOffset.Now : null;

            int rowsEffected;

            try {

                if(hasEvents) {

                    Settings.FireQueryExecutingEvent(
                        database: transaction.Database,
                        sql: DeleteSql,
                        queryType: QueryType.Delete,
                        start: start,
                        isolationLevel: transaction.IsolationLevel,
                        transactionId: transaction.TransactionId,
                        timeout: timeout.Value,
                        debugName: debugName
                    );
                }

#if DEBUG
                DebugHelper.HitBreakPoint(QueryType.Delete);
#endif

                using(DbCommand command = transaction.CreateCommand(timeout.Value)) {

                    command.CommandText = DeleteSql;

                    SetParameters(existingRow, command.Parameters, WhereClauseParameterCreators);

                    rowsEffected = command.ExecuteNonQuery();

                    if(hasEvents) {

                        Settings.FireQueryPerformedEvent(
                            database: transaction.Database,
                            sql: DeleteSql,
                            rows: 0,
                            rowsEffected: rowsEffected,
                            queryType: QueryType.Delete,
                            result: null,
                            start: start,
                            end: DateTimeOffset.Now,
                            elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                            exception: null,
                            isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                            transactionId: transaction?.TransactionId,
                            timeout: timeout.Value,
                            isAsync: true,
                            debugName: debugName
                        );
                    }
                }
            }
            catch(Exception ex) {

                if(hasEvents) {

                    Settings.FireQueryPerformedEvent(
                        database: transaction.Database,
                        sql: DeleteSql,
                        rows: 0,
                        rowsEffected: 0,
                        queryType: QueryType.Delete,
                        result: null,
                        start: start,
                        end: DateTimeOffset.Now,
                        elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                        exception: ex,
                        isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                        transactionId: transaction?.TransactionId,
                        timeout: timeout.Value,
                        isAsync: true,
                        debugName: debugName
                    );
                }
                throw;
            }
            return rowsEffected;
        }

        public async Task<int> DeleteAsync(ROW existingRow, Transaction transaction, QueryTimeout? timeout, string debugName, CancellationToken ct) {

            ArgumentNullException.ThrowIfNull(transaction);
            ArgumentNullException.ThrowIfNull(debugName);

            if(timeout is null) {
                timeout = TimeoutLevel.ShortDelete;
            }
            bool hasEvents = Settings.HasEvents;

            long? startTicks = hasEvents ? Stopwatch.GetTimestamp() : null;

            DateTimeOffset? start = hasEvents ? DateTimeOffset.Now : null;

            int rowsEffected;

            try {

                if(hasEvents) {

                    Settings.FireQueryExecutingEvent(
                        database: transaction.Database,
                        sql: DeleteSql,
                        queryType: QueryType.Delete,
                        start: start,
                        isolationLevel: transaction.IsolationLevel,
                        transactionId: transaction.TransactionId,
                        timeout: timeout.Value,
                        debugName: debugName
                    );
                }

#if DEBUG
                DebugHelper.HitBreakPoint(QueryType.Delete);
#endif

                await using(DbCommand command = await transaction.CreateCommandAsync(timeout.Value, ct)) {

                    command.CommandText = DeleteSql;

                    SetParameters(existingRow, command.Parameters, WhereClauseParameterCreators);

                    rowsEffected = await command.ExecuteNonQueryAsync(ct);

                    if(hasEvents) {

                        Settings.FireQueryPerformedEvent(
                            database: transaction.Database,
                            sql: DeleteSql,
                            rows: 0,
                            rowsEffected: rowsEffected,
                            queryType: QueryType.Delete,
                            result: null,
                            start: start,
                            end: DateTimeOffset.Now,
                            elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                            exception: null,
                            isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                            transactionId: transaction?.TransactionId,
                            timeout: timeout.Value,
                            isAsync: true,
                            debugName: debugName
                        );
                    }
                }
            }
            catch(Exception ex) {

                if(hasEvents) {

                    Settings.FireQueryPerformedEvent(
                        database: transaction.Database,
                        sql: DeleteSql,
                        rows: 0,
                        rowsEffected: 0,
                        queryType: QueryType.Delete,
                        result: null,
                        start: start,
                        end: DateTimeOffset.Now,
                        elapsedTime: startTicks != null ? Stopwatch.GetElapsedTime(startTicks.Value) : null,
                        exception: ex,
                        isolationLevel: transaction != null ? transaction.IsolationLevel : IsolationLevel.ReadCommitted,
                        transactionId: transaction?.TransactionId,
                        timeout: timeout.Value,
                        isAsync: true,
                        debugName: debugName
                    );
                }
                throw;
            }
            return rowsEffected;
        }

        public static string CreateInsertSql(IDatabase database, TABLE table, List<ColumnAndSetter<ROW>> insertColumns, ColumnAndSetter<ROW>[] returningColumns) {

            StringBuilder sql = StringBuilderCache.Acquire();

            sql.Append("INSERT INTO ");

            string schemaName = database.SchemaMap(table.SchemaName);

            if(!string.IsNullOrWhiteSpace(schemaName)) {
                SqlHelper.AppendEncloseSchemaName(sql, schemaName, database.EncloseWith);
                sql.Append('.');
            }

            EncloseWith encloseWith = database.DatabaseType == DatabaseType.PostgreSql ? EncloseWith.DoubleQuote : EncloseWith.SquareBracket;

            SqlHelper.AppendEncloseTableName(sql, table, encloseWith);

            sql.Append('(');

            for(int index = 0; index < insertColumns.Count; index++) {

                if(index > 0) {
                    sql.Append(',');
                }
                ColumnAndSetter<ROW> cs = insertColumns[index];
                SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
            }

            sql.Append(')');

            if(returningColumns.Length > 0 && database.DatabaseType == DatabaseType.SqlServer) {

                sql.Append(" OUTPUT ");

                for(int index = 0; index < returningColumns.Length; index++) {

                    if(index > 0) {
                        sql.Append(',');
                    }
                    ColumnAndSetter<ROW> cs = returningColumns[index];
                    sql.Append("INSERTED.");
                    SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
                }
            }

            sql.Append(" VALUES(");

            for(int index = 0; index < insertColumns.Count; index++) {

                if(index > 0) {
                    sql.Append(',');
                }
                ColumnAndSetter<ROW> cs = insertColumns[index];
                sql.Append(cs.ParameterName);
            }
            sql.Append(')');

            bool outputReturning = returningColumns.Length > 0 &&
                                   (database.DatabaseType == DatabaseType.PostgreSql ||
                                    database.DatabaseType == DatabaseType.Sqlite);

            if(outputReturning) {

                sql.Append(" RETURNING ");

                for(int index = 0; index < returningColumns.Length; index++) {

                    if(index > 0) {
                        sql.Append(',');
                    }
                    ColumnAndSetter<ROW> cs = returningColumns[index];
                    SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
                }
            }

            string insertSql = sql.ToString();

            StringBuilderCache.Release(sql);
            return insertSql;
        }

        public static string CreateUpdateSql(IDatabase database, TABLE table, List<ColumnAndSetter<ROW>> updateColumns, List<ColumnAndSetter<ROW>> whereClauseColumns) {

            StringBuilder sql = StringBuilderCache.Acquire();

            sql.Append("UPDATE ");

            string schemaName = database.SchemaMap(table.SchemaName);

            if(!string.IsNullOrWhiteSpace(schemaName)) {
                SqlHelper.AppendEncloseSchemaName(sql, schemaName, database.EncloseWith);
                sql.Append('.');
            }

            EncloseWith encloseWith = database.DatabaseType == DatabaseType.PostgreSql ? EncloseWith.DoubleQuote : EncloseWith.SquareBracket;

            SqlHelper.AppendEncloseTableName(sql, table, encloseWith);

            sql.Append(" SET ");

            int columnCount = 0;

            for(int index = 0; index < updateColumns.Count; index++) {

                ColumnAndSetter<ROW> cs = updateColumns[index];

                if(columnCount > 0) {
                    sql.Append(',');
                }
                columnCount++;
                SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
                sql.Append('=').Append(cs.ParameterName);
            }
            GenerateWhereClause(database, whereClauseColumns, sql);

            string updateSql = sql.ToString();

            StringBuilderCache.Release(sql);
            return updateSql;
        }

        private static void GenerateWhereClause(IDatabase database, List<ColumnAndSetter<ROW>> whereClauseColumns, StringBuilder sql) {

            sql.Append(" WHERE ");

            for(int index = 0; index < whereClauseColumns.Count; index++) {

                if(index > 0) {
                    sql.Append(" AND ");
                }
                ColumnAndSetter<ROW> cs = whereClauseColumns[index];
                GenerateWhereClauseCondition(database, sql, cs);
            }
        }

        private static void GenerateWhereClauseCondition(IDatabase database, StringBuilder sql, ColumnAndSetter<ROW> cs) {

            bool isFloatingPoint =
                cs.Column.UnderlyingType == typeof(float) ||
                cs.Column.UnderlyingType == typeof(float?) ||
                cs.Column.UnderlyingType == typeof(double) ||
                cs.Column.UnderlyingType == typeof(double?);

            if(cs.Column.IsNullable) {
                sql.Append("((");
                SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
                sql.Append(" IS NULL AND ").Append(cs.ParameterName).Append(" IS NULL) OR (");
            }

            // Floating point comparison is not reliable so we need to take that into consideration
            if(isFloatingPoint) {
                sql.Append("ABS(");
                SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
                sql.Append('-').Append(cs.ParameterName).Append(") < 0.0000001");   //TODO: Check this value - Maybe different for float and double
            }
            else {
                SqlHelper.AppendEncloseColumnName(sql, cs.Column, database.EncloseWith);
                sql.Append('=').Append(cs.ParameterName);
            }

            if(cs.Column.IsNullable) {
                sql.Append("))");
            }
        }

        public static string CreateDeleteSql(IDatabase database, TABLE table, List<ColumnAndSetter<ROW>> whereClauseColumns) {

            StringBuilder sql = StringBuilderCache.Acquire();

            sql.Append("DELETE FROM ");

            string schemaName = database.SchemaMap(table.SchemaName);

            if(!string.IsNullOrWhiteSpace(schemaName)) {
                SqlHelper.AppendEncloseSchemaName(sql, schemaName, database.EncloseWith);
                sql.Append('.');
            }

            EncloseWith encloseWith = database.DatabaseType == DatabaseType.PostgreSql ? EncloseWith.DoubleQuote : EncloseWith.SquareBracket;

            SqlHelper.AppendEncloseTableName(sql, table, encloseWith);

            GenerateWhereClause(database, whereClauseColumns, sql);

            string deleteSql = sql.ToString();

            StringBuilderCache.Release(sql);
            return deleteSql;
        }
    }
}